"""
backend/core/signal.py - Trade signal model

Represents a BUY/SELL signal generated by a strategy.
"""
from dataclasses import dataclass, asdict
from typing import Optional, Literal
from datetime import datetime


@dataclass
class Signal:
    """
    Represents a trading signal (BUY or SELL).
    
    Attributes:
        type: 'BUY' or 'SELL'
        symbol: Trading symbol
        price: Entry price
        sl: Stop loss level
        tp: Take profit level
        rsi: Current RSI value
        atr: Current ATR value
        confidence: Confidence score (0-100)
        strategy: Strategy name that generated this signal
        time: Timestamp when signal was generated
        target_bars: Estimated bars to reach target
        target_time: Human-readable target time estimate
        target_datetime: Target datetime estimate
    """
    
    type: Literal['BUY', 'SELL']
    symbol: str
    price: float
    sl: float
    tp: float
    rsi: float
    atr: float
    confidence: float
    strategy: str
    time: int  # Unix timestamp
    target_bars: Optional[float] = None
    target_time: Optional[str] = None
    target_datetime: Optional[str] = None
    
    def __post_init__(self):
        """Validate signal integrity."""
        assert self.type in ('BUY', 'SELL'), f"Invalid signal type: {self.type}"
        assert 0 <= self.confidence <= 100, f"Confidence must be 0-100, got {self.confidence}"
        
        if self.type == 'BUY':
            assert self.sl < self.price < self.tp, \
                f"BUY: SL({self.sl}) < Price({self.price}) < TP({self.tp}) required"
        else:  # SELL
            assert self.tp < self.price < self.sl, \
                f"SELL: TP({self.tp}) < Price({self.price}) < SL({self.sl}) required"
    
    def to_dict(self) -> dict:
        """Convert to dict for JSON serialization."""
        d = asdict(self)
        # Round prices for cleaner JSON
        d['price'] = round(d['price'], 4)
        d['sl'] = round(d['sl'], 4)
        d['tp'] = round(d['tp'], 4)
        d['rsi'] = round(d['rsi'], 2)
        d['atr'] = round(d['atr'], 4)
        return d
    
    @property
    def risk_reward_ratio(self) -> float:
        """RR Ratio: (TP - Entry) / (Entry - SL) for BUY."""
        if self.type == 'BUY':
            profit = self.tp - self.price
            risk = self.price - self.sl
        else:
            profit = self.price - self.tp
            risk = self.sl - self.price
        
        if risk <= 0:
            return 0.0
        return round(profit / risk, 2)
    
    @property
    def profit_potential_pct(self) -> float:
        """% profit if target is hit."""
        if self.type == 'BUY':
            return round(((self.tp - self.price) / self.price) * 100, 2)
        else:
            return round(((self.price - self.tp) / self.price) * 100, 2)
    
    @property
    def risk_pct(self) -> float:
        """% loss if stopped out."""
        if self.type == 'BUY':
            return round(((self.price - self.sl) / self.price) * 100, 2)
        else:
            return round(((self.sl - self.price) / self.price) * 100, 2)
